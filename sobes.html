<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Sobes</title>
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap');
		.reg{font-weight: 400;}
		.ireg{font-weight: 400; font-style: italic;}
		.sbold{font-weight: 600;}
		.isbold{font-weight: 600; font-style: italic;}
		.bold{font-weight: 700;}
		.container{
		    width: 1170px;
		    margin: 0 auto;
		}
		@media (max-width: 1200px){.container{max-width: 970px;}}
		@media (max-width: 992px){.container{max-width: 750px;}}
		@media (max-width: 767px){.container{max-width: 90%;}}
		h3{
			margin-block-end: 0.5em;
			margin-block-start: 0em;
			/*padding-top: 3em;*/
		}
		hr{
			margin: 50px 0px;
		}
		p{
			margin-block-start: 0em;
			margin-block-end: 0em;
			padding-left: 15px;
		}
		body{
		    font-family: 'Montserrat';
		    background: rgba(100,100,255,0.12);
		    color: rgba(0,0,0,0.95);
		    line-height: 1.25;
		}
		i{
			color: rgba(0,0,0,0.5);	
		}
		img{
			width: 100%;
			max-width: 400px;
		}
		a:visited{
			color: blue;
		}
		a{
			text-decoration: none;
			transition: 0.5s;
			color: blue;

		}
		a:hover{
			transition: 0.2s;
			text-decoration: rgba(150,150,255,0.9) dotted underline;
		}
		.a_selected{
		    animation: a_selected_anim 2s;
		}
		tr{
			padding: 10px;
		}
		@keyframes a_selected_anim{
		    0% { background: transparent;}	
		    30% { background: rgba(150,150,255,0.4);}
		    100% { background: transparent;}
		} 
	</style>	
</head>
<body>
	<div class="container">
		<div id="cicd">
			<h3>
				CI/CD - Continuous Integration / Continuous Delivery
			</h3>
			<p>
				Это практики которые позволяют разработчикам чаще и надёжнее развёртывать  изменения ПО. СI/CD - одна из DevOps практик и также относится к <a href="#agile">Agile</a> - практике. <br><br>
				Непрерывная интеграция (CI) - методология разработки при которой в код вносятся небольшие изменения с частыми коммитами.  И поскольку большинство современных приложений разрабатываются с использованием различных платформ и инструментов, то появляется необходимость в механизме интеграции и тестировании вносимых изменений. <br><br>
				Цель CI - обеспечить автоматизированный и последовательный способ сборки, упаковки и тестирования приложений <br>
				Цель CD - автоматизировать развёртывание приложений в различные окружения. <br>

				9586
				<a href="https://habr.com/ru/company/otus/blog/515078/">подробнее</a> 

			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="data_types_python">
			<h3>
				Создание <a href="#python">Python</a> проекта через терминал  
			</h3>
			<p>
				<code>
					python -m venv venv <i>// создать папку venv с локальным окружением</i><br>
					echo > main.py <i>// создать файл main.py</i><br>
					venv\Scripts\activate <i>// активация виртуального окружения</i><br>
					вписать имя файла + enter для его открытия <br><br>

					<i>Доп функционал</i><br>
					source venv/bin/activate <i>// открыть (venv) на linux</i><br>
					touch имя файла <i>// создать файл на linux</i><br>
					deactivate<i>// для деактивации виртуального окружения</i><br>
					pip install <i>// далее библиотеки через пробел для установки библиотек</i><br>
					pip install -r requirements.txt<i>// установка всех библиотек из файла</i><br>
					pip uninstall <i>навание</i> -y <i>// для удаления</i> <br>
					pip freeze <i>// для просмотра списка установленных библиотек</i><br>
					pip freeze > requirements.txt<i>// для записи списка установленных библиотек в файл</i><br>
				</code>
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="python">
			<h3>
				Python 
			</h3>
			<p>
				Создание проекта
				<a href="#data_types_python">Типы данных </a><br>
				
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="data_types_python">
			<h3>
				Типы данных в <a href="#python">Python</a> 
			</h3>
			<p>
				<b>Изменяемые:</b> <a href="#list_python">list</a> dict set <br>
				<b>Неизменяемые:</b> int float string bool nontype tuple frozen-set и остальные<br><br>
				При любой попытке изменить неизменяемый объект, в памяти создаётся новый объект.
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="diff_between_rr_and_is">
			<h3>
				Разница между == и is в <a href="#python">Python</a> 
			</h3>
			<p>
				<b>==</b> сравнивает по значениям
				<b>is</b> сравнивает по адресам в памяти 
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="list_python">
			<h3>
				List в <a href="#python">Python</a> 
			</h3>
			<p>
				List (список) в <a href="#python">Python</a> - упорядоченная изменяемая коллекция объектов произвольных типов (почти как массив, но типы могут отличаться). Сложность поиска O(n). <br><br>
				<table border="1" class="docutils"><thead valign="bottom"><tr><th class="head">Метод</th><th class="head">Что делает</th></tr></thead><tbody valign="center"><tr><td><b>list.append</b>(x)</td><td>Добавляет элемент в конец списка</td></tr><tr><td><b>list.extend</b>(L)</td><td>Расширяет список list, добавляя в конец все элементы списка L</td></tr><tr><td><b>list.insert</b>(i, x)</td><td>Вставляет на i-ый элемент значение x</td></tr><tr><td><b>list.remove</b>(x)</td><td>Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует</td></tr><tr><td><b>list.pop</b>([i])</td><td>Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент</td></tr><tr><td><b>list.index</b>(x, [start [, end]])</td><td>Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)</td></tr><tr><td><b>list.count</b>(x)</td><td>Возвращает количество элементов со значением x</td></tr><tr><td><b>list.sort</b>([key=функция])</td><td>Сортирует список на основе функции</td></tr><tr><td><b>list.reverse</b>()</td><td>Разворачивает список</td></tr><tr><td><b>list.copy</b>()</td><td>Поверхностная копия списка</td></tr><tr><td><b>list.clear</b>()</td><td>Очищает список</td></tr><tr><td><b>list('string')</b></td><td>Создаёт список ['s', 't', 'r', 'i', 'n', 'g']</td></tr></tbody></table>
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="list_python">
			<h3>
				Tuple в <a href="#python">Python</a> 
			</h3>
			<p>
				Сегодня я расскажу о таком типе данных, как кортежи (tuple) и о том, где они применяются.

				Кортеж, по сути - неизменяемый список.

				Зачем нужны кортежи, если есть списки?
				Защита от дурака. То есть кортеж защищен от изменений, как намеренных (что плохо), так и случайных (что хорошо).
				Меньший размер. Дабы не быть голословным:
				>>>
				>>> a = (1, 2, 3, 4, 5, 6)
				>>> b = [1, 2, 3, 4, 5, 6]
				>>> a.__sizeof__()
				36
				>>> b.__sizeof__()
				44
				Возможность использовать кортежи в качестве ключей словаря:
				>>>
				>>> d = {(1, 1, 1) : 1}
				>>> d
				{(1, 1, 1): 1}
				>>> d = {[1, 1, 1] : 1}
				Traceback (most recent call last):
				  File "", line 1, in
				    d = {[1, 1, 1] : 1}
				TypeError: unhashable type: 'list'
				Как работать с кортежами?
				С преимуществами кортежей разобрались, теперь встает вопрос - а как с ними работать. Примерно так же, как и со списками.

				Создаем пустой кортеж:

				>>>
				>>> a = tuple() # С помощью встроенной функции tuple()
				>>> a
				()
				>>> a = () # С помощью литерала кортежа
				>>> a
				()
				>>>
				Создаем кортеж из одного элемента:

				>>>
				>>> a = ('s')
				>>> a
				's'
				Стоп. Получилась строка. Но как же так? Мы же кортеж хотели! Как же нам кортеж получить?

				>>>
				>>> a = ('s', )
				>>> a
				('s',)
				Ура! Заработало! Все дело - в запятой. Сами по себе скобки ничего не значат, точнее, значат то, что внутри них находится одна инструкция, которая может быть отделена пробелами, переносом строк и прочим мусором. Кстати, кортеж можно создать и так:

				>>>
				>>> a = 's',
				>>> a
				('s',)
				Но все же не увлекайтесь, и ставьте скобки, тем более, что бывают случаи, когда скобки необходимы.

				Ну и создать кортеж из итерируемого объекта можно с помощью все той же пресловутой функции tuple()

				>>>
				>>> a = tuple('hello, world!')
				>>> a
				('h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!')
				Операции с кортежами
				Все операции над списками, не изменяющие список (сложение, умножение на число, методы index() и count() и некоторые другие операции). Можно также по-разному менять элементы местами и так далее.

				Например, гордость программистов на python - поменять местами значения двух переменных:

				a, b = b, a
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="dict_python">
			<h3>
				Dict в <a href="#python">Python</a> 
			</h3>
			<p>
				Dictionary (словарь) в Python - неупорядоченная изменяемая коллекция произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами. Сложность поиска O(1).<br><br>
				<table border="1" class="docutils">
					<thead valign="bottom">
						<tr><th class="head">Метод</th><th class="head">Что делает</th></tr>
					</thead>
					<tbody valign="center">
						<tr>
							<td>
								<b>dict.clear()</b>
							</td>
							<td>
								Очищает словарь.
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.copy()</b>
							</td>
							<td>
								Возвращает копию словаря.
							</td>
						</tr>
						<tr>
							<td>
								<i>classmethod</i> <b>dict.fromkeys(seq[, value])</b>
							</td>
							<td>
								Cоздает словарь с ключами из seq и значением value (по умолчанию None).
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.items()</b>
							</td>
							<td>
								Возвращает пары (ключ, значение).
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.get(key[, default])</b>
							</td>
							<td>
								Возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.keys()</b>
							</td>
							<td>
								Возвращает ключи в словаре.
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.pop(key[, default])</b>
							</td>
							<td>
								Удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.popitem()</b>
							</td>
							<td>
								Удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.setdefault(key[, default])</b>
							</td>
							<td>
								Возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.update([other])</b>
							</td>
							<td>
								Обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).
							</td>
						</tr>
						<tr>
							<td>
								<b>dict.values()</b>
							</td>
							<td>
								Возвращает значения в словаре.
							</td>
						</tr>
					</tbody>
				</table>
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="hash_table">
			<h3>
				Hash-table (Хэш-таблица)
			</h3>
			<p>
				Структура данных позволяющая быстро получать информацию по ключю в не зависимотси от количества имеющихся данных. 
				<br><br>
				Из ключа, при помощи хеш функции, мы получаем индекс элемента, которых хранится в таблице. 
				<br><br>
				Позже, мы можем применить хеш функцию для вычесления индекса из ключа и быстрого поиска значения в таблице.
				<br><br>
				Могут случаться ситуация когда результат применения хэш-функии на два разных ключа выдаст одинаковые значения, такая ситуация называется коллизией.
				<br><br>
				Существует два популярных метода устранения коллизии: <br>
				- Метод открытой адресации - информация записывается в следующую свободную ячейку по определённым правилам (через одну, через степень двойки и тп)<br>
				- Метод цепочек - мы добавляем в ячейку ссылку на область памяти в которой будет хранится текущее значение<br>
				- Метод двойного хеширования - берётся хеш от хеша<br>
				<img src="img/hash_table_collision_chain.png" alt="">
				<br><br>
				<img src="img/collisions_plus_minus.png" alt="">
			</p>
		</div>


<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="hash_table">
			<h3>
				Hash-function (Хэш-функция)
			</h3>
			<p>
				Функция, осуществляющая преобразование входных данных произвольной длины в выходную строку установленной длины, выполняемое определённым алгоритмом. <br><br>
				Хорошая хэш-функия должна отвечать определённым требованиям:<br>
				- Детерминизм - для одного и того же значения ключа функция должна выдавать одно и то же значение; <br>
				- Равномерность - для разных ключей функция должна выдавать разные значания; <br>
				- Эффективность - чем быстрее вычисляется функция тем лучше; <br>
				- Ограниченность - выдаваемые фукнцией значения должны быть ограничены (пример: 0 < результат функции < размер хеш таблицы для который функция вычисляется) <br> <br>

				Для чего она нужна? - Для хеш-таблиц, индексирования в БД и для хранения паролей в БД.
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="hash_table">
			<h3>
				Тип данных Set в <a href="#python">Python</a> 
			</h3>
			<p>
				Множество в python - "контейнер", содержащий не повторяющиеся элементы в случайном порядке. Сложность поиска O(1).
				С множествами можно выполнять множество операций: находить объединение, пересечение...

len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.
set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
set == other - все элементы set принадлежат other, все элементы other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких множеств.
set.intersection(other, ...) или set & other & ... - пересечение.
set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.copy() - копия множества.
И операции, непосредственно изменяющие множество:

set.update(other, ...); set |= other | ... - объединение.
set.intersection_update(other, ...); set &= other & ... - пересечение.
set.difference_update(other, ...); set -= other | ... - вычитание.
set.symmetric_difference_update(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.add(elem) - добавляет элемент в множество.
set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
set.discard(elem) - удаляет элемент, если он находится в множестве.
set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
set.clear() - очистка множества.
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="hash_table">
			<h3>
				Тип данных Frozenset в <a href="#python">Python</a> 
			</h3>
			<p>
				Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет. Примерно похожая ситуация с списками и кортежами. Сложность поиска O(1).
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="hash_table">
			<h3>
				Что такое класс в <a href="#python">Python</a> 
			</h3>
			<p>
				Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет. Примерно похожая ситуация с списками и кортежами. Сложность поиска O(1).
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="db">
			<h3>
				Как оценивается сложность алгоритмов - Big O (Большое О, Оценка скорости алгоритма)
			</h3>
			<p>
				Можно оценивать сложность алгоритмов при помощи времени выполнения программы, но это не объективно, т.к. все процессоры работают с разной скоростью, но одна и та же программа на разных процессорах выполнится за одинаковое количество тактов, а уже скорость выполнения этих тактов зависит от мощности процессора.
				Big O показывает темп роста функции, следовательно мы не учитываем константы и "неважную" сложность <br>
				Последовательность действий - сложение, вложенные действия - умножение <br>
				Для алгоритма где на каждой итерации берётся половина элементов - сложность будет O(log n)
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="db">
			<h3>
				БД - База Данных
			</h3>
			<p>
				9586
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="transaction">
			<h3>
				Транзакция
			</h3>
			<p>
				Последовательность команд SQL, которые должны быть выполнены полностью или не выполнены вообще.
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<h3>
			Как создать <a href="#transaction">транзакцию</a> 
		</h3>
		<p>
			<code>START TRANSACTION; <br><br>
			SELECT ...; <br>
			UPDATE ...; <br>
			INSERT ...; <br>
			ДРУГИЕ ЗАПРОСЫ ...;<br><br>
			COMMIT; <i>// для записи в базу данных всех запросов</i><br>
			или <br>
			ROLLBACK; <i>// для отмены всех изменений которые выполнила транзакция</i>
			</code>
		</p>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<h3>
			Завершение <a href="#transaction">транзакций</a> 
		</h3>
		<p>
			- Команды <code>COMMIT</code> или <code>ROLLBACK</code> <br>
			- <code>ALTER_TABLE</code> или <code>CREATE_TABLE</code> фиксируют все транзакции <br>
			- Сбой СУБД откатывает все транзакции<br>
			- Сбой клиента СУБД откатывает все транзакции после тайм-аута
		</p>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<h3>
			Автоматическая фиксация <a href="#transaction">транзакций</a> 
		</h3>
		<p>
			Режим в котором после выполнения каждой команды SQL автоматически фиксируется транзакция<br>
			По умолчанию этот режим включён в PostgreSQL
		</p>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="db_index">
			<h3>
				Индексы в <a href="#db">БД</a> 
			</h3>
			<p>
				Это метод структуры данных, который позволяет вам быстро извлекать записи из файла базы данных. Индекс – это небольшая таблица, имеющая всего два столбца. Первый столбец содержит копию первичного или потенциального ключа таблицы. Его второй столбец содержит набор указателей для хранения адреса дискового блока, где хранится это конкретное значение ключа. <br><br>
				Индексация ускоряет фильтрацию, объеденение и сортировку данных по столбцу (если для этого столбцов существует индекс) <br><br>
				Почему повсеместно не использовать индексы? - Изменение данных в индексированном столбце влечёт за собой обновление самого столбца, что при большой нагрузке на базу, существенно уменьшит производительность. Индексирование улучшает работу чтения, но ухудшает работу записи<br><br>
				Индексация базы данных определяется на основе ее атрибутов индексации. Два основных типа методов индексации:<br><br>

				<a href="#bd_primary_index">Первичный индекс</a><br>
				<a href="#bd_secondary_index">Вторичный индекс</a>
			</p>
		</div>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="db_create_index">
			<h3>
				Как создать <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				Создание<br>
				<code>CREATE INDEX имя-таблицы_имя-стобца_idx ON имя-таблицы(имя-столбца)</code><br><br>
				Удаление<br>
				<code>DROP INDEX имя-таблицы_имя-стобца_idx ON имя-таблицы(имя-столбца)</code>
			</p>
		</div>
		
<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="bd_primary_index">
			<h3>
				Первичный <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				Это файл c двумя полями. Первое поле – это первичный ключ, второе поле указывает на блок данных. В первичном индексе всегда существует отношение один к одному между записями в таблице индекса. <br><br>
				Первичная индексация также делится на два типа. <br><br>
				<a href="#db_dense_index">Плотный индекс</a> <br>
				<a href="#db_sparse_index">Разреженный индекс</a>
			</p>
		</div>
		
<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="db_dense_index">
			<h3>
				Плотный <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				В плотном <a href="#db_index">индексe</a> запись создается для каждого поискового ключа. Это помогает выполнять поиск быстрее в сравнении с <a href="#db_sparse_index">разреженным индексированием</a>, но требует больше места для хранения записей индекса. В этом индексировании записи метода содержат значение ключа поиска и указывают на реальную запись на диске. <br><br>
				<img src="img/db_dense_index.png" alt="">
			</p>
		</div>
		
<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="db_sparse_index">
			<h3>
				Разреженный <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				В разрежённом <a href="#db_index">индексe</a> запись создается только для некоторых поисковых ключей. Разреженный индекс поможет вам решить проблемы <a href="#db_dense_index">плотного индексирования</a>. Ему требуется меньше места, меньше затрат на обслуживание для вставки и удаления, но он медленнее по сравнению с <a href="#db_dense_index">плотным индексом</a> для поиска записей. <br><br>
				<img src="img/db_sparse_index.png" alt="">
			</p>
		</div>
		
<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<div id="bd_secondary_index">
			<h3>
				Вторичный <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				Вторичный <a href="#db_index">индекс</a> может быть создан с помощью поля, которое имеет уникальное значение для каждой записи, и это должен быть потенциальный ключ. Он также известен как некластеризованный индекс.
				перечитать, тут все ответы на все вопросы https://habr.com/ru/post/247373/
			</p>
		</div>
		
<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.  -->

		<h3 id="db_joins">
			Суперключ в <a href="#db">БД</a> 
		</h3>
		<p>
			Superkey (суперключ) - комбинация атрибутов (столбцов), которые уникально идентифицируют каждую строку таблицы. Это могут быть и все столбцы, и несколько и и один. При этом строки, которые содержат значения этих атрибутов, не должны повторяться. <br><br>
			Например, у нас есть сущность Student, которая представляет данные о пользователях и которая имеет следующие атрибуты:<br><br>
			- FirstName (имя)<br>
			- LastName (фамилия)<br>
			- Year (год рождения)<br>
			- Phone (номер телефона)<br><br>
			Какие атрибуты в данном случае могут составлять суперключ:<br><br>
			- {FirstName, LastName, Year, Phone}<br>
			- {FirstName, Year, Phone}<br>
			- {LastName, Year, Phone}<br>
			- {FirstName, Phone}<br>
			- {LastName, Phone}<br>
			- {Year, Phone}<br>
			- {Phone}<br><br>
			Каждого студента уникально может идентифицировать телефонный номер, поэтому любые наборы, в которых встречается атрибут Phone, представляют суперключ. <br><br>

			А вот, к примеру, набор {FirstName, LastName, Year} не является суперключом, так как у нас теоретически могут быть как минимум два студента с одинаковыми именем, фамилией и годом рождения.
		</p>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->
		
		<h3 id="db_joins">
			Потенциальный ключ в <a href="#db">БД</a> 
		</h3>
		<p>
			<b>Candidat key (потенциальный ключ)</b> - представляет собой минимальный суперключ таблицы, то есть набор атрибутов, который удовлетворяет ряду условий:<br><br>
			<b>Неприводимость:</b> он не может быть сокращен, он содержит минимально возможный набор атрибутов; <br>
			<b>Уникальность:</b> он должен иметь уникальные значения вне зависимости от изменения строки;<br>
			<b>Наличие значения:</b> он не должен иметь значения NULL, то есть он обязательно должен иметь значение. <br><br>
			Возьмем ранее выделенные суперключи и найдем среди них candidate key. Большинство из них не соответствуют первому условию, так как все их можно сократить до суперключа {Phone}. <br><br>
			Суперключ {Phone} соответствует первому и второму условию, так как он имеет уникальное значение (в данном случае все пользователи могут иметь только уникальные телефонные номера). Но соответствует ли он третьему условию? В целом нет, так как теоретически студент может и не иметь телефона. В этом случае атрибут Phone будет иметь значение NULL, то есть значение будет отсутствовать. <br><br>
			В то же время это может зависеть от ситуации. Если в какой-то систему номер телефона является неотъемлемым атрибутом, например, используется для регистрации и входа в систему, то его можно считать потенциальным ключом. Но в данном случае мы рассматриваем общую ситуацию. И для понимания потенциального ключа необходимо отталкиваться от конкретной системы, которую описывает база данных. <br><br>
			И в таком случае суперключи таблицы не содержат потенциального ключа.
		</p>
		
<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<h3 id="db_joins">
			Первичный ключ в <a href="#db">БД</a> 
		</h3>
		<p>
			Первичный ключ (primary key) непосредственно применяется для идентификации строк в таблице. Он должен соответствовать следующим ограничениям:<br><br>
			Первичный ключ должен быть уникальным все время; <br>
			Он должен постоянно присутствовать в таблице и иметь значение;<br>
			Он не должен часто менять свое значение. В идеале он вообще не должен изменять значение. <br><br>
			Как правило, первичный ключ представляет один столбец таблицы, но также может быть составным и состоять из нескольких столбцов.

			Если для таблицы можно выделить потенциальный ключ, то его можно использовать в качестве первичного ключа.

			Если же потенциальные ключи отсутствуют, то для первичного ключа можно добавить к сущности специальный атрибут, который, как правило, называется, Id или имеет форму [Имя_сущности]Id (например, StudentId), либо может иметь другое название. И обычно данный атрибут принимает целочисленное значение, начиная с 1.

			Если же у нас есть несколько потенциальных ключей, то те потенциальные ключи, которые не составляют первичный ключ, являются альтернативными ключами (alternative key).

			Например, возьмем представление пользователей на сайтах с двухфакторной авторизацией, где нам обязательно иметь электронный адрес, который нередко выступает в качестве логина, и какой-нибудь номер телефона. В этом случае таблицу пользователей мы можем задать с помощью следующих атрибутов:

			Name (имя пользователя)

			Email (электронный адрес)

			Password (пароль)

			Phone (телефонный номер)

			В данном случае атрибуты Email и Phone являются потенциальными ключами, они обязательны в рамках рассматриваемой системы и в принципе уникальны. И теоретически, мы можем использовать один из этих атрибутов в качестве первичного ключа, тогда второй будет альтернативным ключом. Однако опять же поскольку теоретически значения обоих атрибутов могут меняться, то лучше все таки определить дополнительный атрибут специально под первичный ключ.
		</p>
		
<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<h3 id="db_joins">
			JOINS в <a href="#db">БД</a> 
		</h3>
		<p>
			9586
		</p>

<hr> <!-- -=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-.-=|=-. -->

		<h3 id='orm'>
			ORM - Object Relation Mapping
		</h3>
		<p>
			9586
		</p>
		<!-- -------------- -->
		<h3 id='agile'>
			Agile
		</h3>
		<p>
			9586
		</p>
	</div>
	<script>
		var as = document.getElementsByTagName('a');
		for (let i = 0; i < as.length; i++) {
			as[i].onclick = function(){
				var str = this.href;
				str = str.slice(str.indexOf('#') - str.length+1);
				document.getElementById(str).classList.add('a_selected');
				setTimeout(remove_a_selected,3200,str);
			};
		}
		function remove_a_selected(id) {
			document.getElementById(id).classList.remove('a_selected');
		}
	</script>
</body>
</html>

