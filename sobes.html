<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Sobes</title>
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap');
		.reg{font-weight: 400;}
		.ireg{font-weight: 400; font-style: italic;}
		.sbold{font-weight: 600;}
		.isbold{font-weight: 600; font-style: italic;}
		.bold{font-weight: 700;}
		.container{
		    width: 1170px;
		    margin: 0 auto;
		}
		@media (max-width: 1200px){.container{max-width: 970px;}}
		@media (max-width: 992px){.container{max-width: 750px;}}
		@media (max-width: 767px){.container{max-width: 90%;}}
		h3{
			margin-block-end: 0em;
			padding-top: 3em;
		}
		p{
			margin-block-start: 0.25em;
			margin-block-end: 0em;
			padding-left: 15px;
		}
		body{
		    font-family: 'Montserrat';
		    background: rgba(100,100,255,0.12);
		    color: rgba(0,0,0,0.95);
		    line-height: 1.25;
		}
		img{
			width: 100%;
			max-width: 400px;
		}
		a:visited{
			color: blue;
		}
		a{
			text-decoration: none;
			transition: 0.5s;
			color: blue;

		}
		a:hover{
			transition: 0.2s;
			text-decoration: rgba(150,150,255,0.9) dotted underline;
		}
		.a_selected{
		    animation: a_selected_anim 2s;
		}
		@keyframes a_selected_anim{
		    0% { background: transparent;}	
		    30% { background: rgba(150,150,255,0.4);}
		    100% { background: transparent;}
		} 
	</style>	
</head>
<body>
	<div class="container">
		<div id="cicd">
			<h3>
				CI/CD - Continuous Integration / Continuous Delivery
			</h3>
			<p>
				Это практики которые позволяют разработчикам чаще и надёжнее развёртывать  изменения ПО. СI/CD - одна из DevOps практик и также относится к <a href="#agile">Agile</a> - практике. <br><br>
				Непрерывная интеграция (CI) - методология разработки при которой в код вносятся небольшие изменения с частыми коммитами.  И поскольку большинство современных приложений разрабатываются с использованием различных платформ и инструментов, то появляется необходимость в механизме интеграции и тестировании вносимых изменений. <br><br>
				Цель CI - обеспечить автоматизированный и последовательный способ сборки, упаковки и тестирования приложений <br>
				Цель CD - автоматизировать развёртывание приложений в различные окружения. <br>

				9586
				<a href="https://habr.com/ru/company/otus/blog/515078/">подробнее</a> 

			</p>
		</div>
		<!-- -------------- -->
		<div id="db">
			<h3>
				БД - База Данных
			</h3>
			<p>
				9586
			</p>
		</div>
		<!-- -------------- -->
		<div id="transaction">
			<h3>
				Транзакция
			</h3>
			<p>
				Последовательность команд SQL, которые должны быть выполнены полностью или не выполнены вообще.
			</p>
		</div>
		<!-- -------------- -->
		<h3>
			Как создать <a href="#transaction">транзакцию</a> 
		</h3>
		<p>
			<code>START TRANSACTION; <br><br>
			SELECT ...; <br>
			UPDATE ...; <br>
			INSERT ...; <br>
			ДРУГИЕ ЗАПРОСЫ ...;<br><br>
			COMMIT; // для записи в базу данных всех запросов<br>
			или <br>
			ROLLBACK; // для отмены всех изменений которые выполнила транзакция
			</code>
		</p>
		<!-- -------------- -->
		<h3>
			Завершение <a href="#transaction">транзакций</a> 
		</h3>
		<p>
			- Команды <code>COMMIT</code> или <code>ROLLBACK</code> <br>
			- <code>ALTER_TABLE</code> или <code>CREATE_TABLE</code> фиксируют все транзакции <br>
			- Сбой СУБД откатывает все транзакции<br>
			- Сбой клиента СУБД откатывает все транзакции после тайм-аута
		</p>
		<!-- -------------- -->
		<h3>
			Автоматическая фиксация <a href="#transaction">транзакций</a> 
		</h3>
		<p>
			Режим в котором после выполнения каждой команды SQL автоматически фиксируется транзакция<br>
			По умолчанию этот режим включён в PostgreSQL
		</p>
		<!-- -------------- -->
		<div id="db_index">
			<h3>
				Индексы в <a href="#db">БД</a> 
			</h3>
			<p>
				Это метод структуры данных, который позволяет вам быстро извлекать записи из файла базы данных. Индекс – это небольшая таблица, имеющая всего два столбца. Первый столбец содержит копию первичного или потенциального ключа таблицы. Его второй столбец содержит набор указателей для хранения адреса дискового блока, где хранится это конкретное значение ключа. <br><br>
				Индексация ускоряет фильтрацию, объеденение и сортировку данных по столбцу (если для этого столбцов существует индекс) <br><br>
				Почему повсеместно не использовать индексы? - Изменение данных в индексированном столбце влечёт за собой обновление самого столбца, что при большой нагрузке на базу, существенно уменьшит производительность. Индексирование улучшает работу чтения, но ухудшает работу записи<br><br>
				Индексация базы данных определяется на основе ее атрибутов индексации. Два основных типа методов индексации:<br><br>

				<a href="#bd_primary_index">Первичный индекс</a><br>
				<a href="#bd_secondary_index">Вторичный индекс</a>
			</p>
		</div>
		<!-- -------------- -->
		<div id="db_create_index">
			<h3>
				Как создать <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				Создание<br>
				<code>CREATE INDEX имя-таблицы_имя-стобца_idx ON имя-таблицы(имя-столбца)</code><br><br>
				Удаление<br>
				<code>DROP INDEX имя-таблицы_имя-стобца_idx ON имя-таблицы(имя-столбца)</code>
			</p>
		</div>
		<!-- -------------- -->
		<div id="bd_primary_index">
			<h3>
				Первичный <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				Это файл c двумя полями. Первое поле – это первичный ключ, второе поле указывает на блок данных. В первичном индексе всегда существует отношение один к одному между записями в таблице индекса. <br><br>
				Первичная индексация также делится на два типа. <br><br>
				<a href="#db_dense_index">Плотный индекс</a> <br>
				<a href="#db_sparse_index">Разреженный индекс</a>
			</p>
		</div>
		<!-- -------------- -->
		<div id="db_dense_index">
			<h3>
				Плотный <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				В плотном <a href="#db_index">индексe</a> запись создается для каждого поискового ключа. Это помогает выполнять поиск быстрее в сравнении с <a href="#db_sparse_index">разреженным индексированием</a>, но требует больше места для хранения записей индекса. В этом индексировании записи метода содержат значение ключа поиска и указывают на реальную запись на диске. <br><br>
				<img src="img/db_dense_index.png" alt="">
			</p>
		</div>
		<!-- -------------- -->
		<div id="db_sparse_index">
			<h3>
				Разреженный <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				В разрежённом <a href="#db_index">индексe</a> запись создается только для некоторых поисковых ключей. Разреженный индекс поможет вам решить проблемы <a href="#db_dense_index">плотного индексирования</a>. Ему требуется меньше места, меньше затрат на обслуживание для вставки и удаления, но он медленнее по сравнению с <a href="#db_dense_index">плотным индексом</a> для поиска записей. <br><br>
				<img src="img/db_sparse_index.png" alt="">
			</p>
		</div>
		<!-- -------------- -->
		<div id="bd_secondary_index">
			<h3>
				Вторичный <a href="#db_index">индекс</a> в <a href="#db">БД</a> 
			</h3>
			<p>
				Вторичный <a href="#db_index">индекс</a> может быть создан с помощью поля, которое имеет уникальное значение для каждой записи, и это должен быть потенциальный ключ. Он также известен как некластеризованный индекс.
				перечитать, тут все ответы на все вопросы https://habr.com/ru/post/247373/
			</p>
		</div>
		<!-- -------------- -->
		<h3 id="db_joins">
			Суперключ в <a href="#db">БД</a> 
		</h3>
		<p>
			Superkey (суперключ) - комбинация атрибутов (столбцов), которые уникально идентифицируют каждую строку таблицы. Это могут быть и все столбцы, и несколько и и один. При этом строки, которые содержат значения этих атрибутов, не должны повторяться. <br><br>
			Например, у нас есть сущность Student, которая представляет данные о пользователях и которая имеет следующие атрибуты:<br><br>
			- FirstName (имя)<br>
			- LastName (фамилия)<br>
			- Year (год рождения)<br>
			- Phone (номер телефона)<br><br>
			Какие атрибуты в данном случае могут составлять суперключ:<br><br>
			- {FirstName, LastName, Year, Phone}<br>
			- {FirstName, Year, Phone}<br>
			- {LastName, Year, Phone}<br>
			- {FirstName, Phone}<br>
			- {LastName, Phone}<br>
			- {Year, Phone}<br>
			- {Phone}<br><br>
			Каждого студента уникально может идентифицировать телефонный номер, поэтому любые наборы, в которых встречается атрибут Phone, представляют суперключ. <br><br>

			А вот, к примеру, набор {FirstName, LastName, Year} не является суперключом, так как у нас теоретически могут быть как минимум два студента с одинаковыми именем, фамилией и годом рождения.
		</p>
		<!-- -------------- -->
		<h3 id="db_joins">
			Потенциальный ключ в <a href="#db">БД</a> 
		</h3>
		<p>
			Candidate key (потенциальный ключ) - представляет собой минимальный суперключ отношения (таблицы), то есть набор атрибутов, который удовлетворяет ряду условий:

			Неприводимость: он не может быть сокращен, он содержит минимально возможный набор атрибутов

			Уникальность: он должен иметь уникальные значения вне зависимости от изменения строки

			Наличие значения: он не должен иметь значения NULL, то есть он обязательно должен иметь значение.

			Возьмем ранее выделенные суперключи и найдем среди них candidate key. Первый пять суперключей не соответствуют первому условию, так как все их можно сократить до суперключа {Phone}:

			{FirstName, LastName, Year, Phone}

			{FirstName, Year, Phone}

			{LastName, Year, Phone}

			{FirstName, Phone}

			{LastName, Phone}

			{Year, Phone}

			Суперключ {Phone} соответствует первому и второму условию, так как он имеет уникальное значение (в данном случае все пользователи могут иметь только уникальные телефонные номера). Но соответствует ли он третьему условию? В целом нет, так как теоретически студент может и не иметь телефона. В этом случае атрибут Phone будет иметь значение NULL, то есть значение будет отсутствовать.

			В то же время это может зависеть от ситуации. Если в какой-то систему номер телефона является неотъемлемым атрибутом, например, используется для регистрации и входа в систему, то его можно считать потенциальным ключом. Но в данном случае мы рассматриваем общую ситуацию. И для понимания потенциального ключа необходимо отталкиваться от конкретной системы, которую описывает база данных.

			И в таком случае суперключи таблицы не содержат потенциального ключа.
		</p>
		<!-- -------------- -->
		<h3 id="db_joins">
			JOINS в <a href="#db">БД</a> 
		</h3>
		<p>
			9586
		</p>
		<!-- -------------- -->
		<h3 id='orm'>
			ORM - Object Relation Mapping
		</h3>
		<p>
			9586
		</p>
		<!-- -------------- -->
		<h3 id='agile'>
			Agile
		</h3>
		<p>
			9586
		</p>
		<!-- -------------- -->
	</div>
	<script>
		var as = document.getElementsByTagName('a');
		for (let i = 0; i < as.length; i++) {
			as[i].onclick = function(){
				var str = this.href;
				str = str.slice(str.indexOf('#') - str.length+1);
				document.getElementById(str).classList.add('a_selected');
				setTimeout(remove_a_selected,3200,str);
			};
		}
		function remove_a_selected(id) {
			document.getElementById(id).classList.remove('a_selected');
		}
	</script>
</body>
</html>

